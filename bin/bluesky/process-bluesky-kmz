#!/usr/bin/env python

"""process-bluesky-kmz

Note: This script is avoids importing from the pyairfire package
so that it is easily distributable.
"""

__author__      = "Joel Dubowy"
__copyright__   = "Copyright (c) 2015 AirFire, PNW, USFS"

import fnmatch
import logging
import os
import sys
import time
import xmltodict
from argparse import (
    ArgumentParser, RawTextHelpFormatter, Action, ArgumentTypeError
)

EXAMPLES = """
Basic examples:

 $ process-bluesky-kmz --log-level=DEBUG -i /path/to/NAM84/ -o /path/to/data/
"""


class ParseColorMap(Action):
    def __call__(self, parser, namespace, values, option_string=None):
        d = getattr(namespace, self.dest)
        for m in values.split(','):
            try:
                b, a = m.split(':')
                d[b] = a
            except ValueError:
                raise ArgumentTypeError(
                    "Invalid --color-map value '{}'".format(values))

def parse_args():
    parser = ArgumentParser(formatter_class=RawTextHelpFormatter)
    parser.add_argument('-i', '--input-dir', required=True,
        help="e.g. /path/to/NAM/4km/",)
    parser.add_argument('-o', '--output-dir', required=True,
        help="e.g. /path/to/data/dir/")
    parser.add_argument('--input-filename', default='smoke_dispersion.kmz',
        help="name of input file to find; defaults to 'smoke_dispersion.kmz'")
    parser.add_argument('--output-filename', default='egp.kmz',
        help="base name of timestamped output file, and name of sym link; "
        "defaults to 'egp.kmz'")
    # TODO: option to override sym link name, with default to output file
    #    base name ?
    parser.add_argument('-l', '--log-level', default="WARN",
        help="Log level - 'DEBUG', 'INFO', 'WARN', 'ERROR'")

    # TODO: add option to skip stripping of legend and logo
    parser.epilog = EXAMPLES
    return parser.parse_args()

def configure_logging(args):
    logging.basicConfig(level=getattr(logging, args.log_level))
    for k, v in args.__dict__.items():
        logging.debug('%s: %s', k, v)

def validate_args(args):
    if not os.path.isdir(args.input_dir):
        logging.error("Input root dir %s does not exist", args.input_dir)
        sys.exit(1)
    if not os.path.isdir(args.output_dir):
        # TODO: should we just create it if it doesn't exist?
        logging.error("Out dir %s does not exist", args.output_dir)
        sys.exit(1)

def determine_timestamp(filename):
    # TODO: extract timestamp from path - i.e. run's initialization
    #    time - if possible
    return time.ctime(os.path.getmtime(filename))

def find_latest(input_dir, input_filename):
    input_file_pathname = timestamp = None

    for root, dirnames, filenames in os.walk(input_dir):
        for filename in fnmatch.filter(filenames, input_filename):
            pathname = os.path.join(root, filename)
            ts = determine_timestamp(pathname)
            logging.debug("Found %s (last modified %s)", pathname, ts)
            if not input_file_pathname or timestamp < ts:
                input_file_pathname = pathname
                timestamp = ts

    return input_file_pathname, timestamp

def generate_output_file_pathname(output_dir, output_filename, timestamp):
    # generate timestamped filename
    parts = output_filename.split('.')
    timestamped_file_name = '-'.join([parts[0], timestamp])
    if len(parts) > 1:
        timestamped_file_name = '.'.join([
           timestamped_file_name, '.'.join(parts[1:])])
    return os.path.join(output_dir, timestamped_file_name)

def input(input_file_pathname):
    # TODO: unzip before open
    with open(input_file_pathname, 'r') as f:
        data = f.read()
    return xmltodict.parse(data)


## ***** BEGIN Copied from osutils.py *****

## create_working_dir is copied here to avoid need to install
## pyairfire where this script is installed

class create_working_dir(object):
    def __enter__(self):
        self._original_dir = os.getcwd()
        self._working_dir = tempfile.mkdtemp()
        logging.debug('chdir to working directory %s', self._working_dir)
        os.chdir(self._working_dir)
        return self._working_dir

    def __exit__(self, type, value, traceback):
        logging.debug('chdir back to original directory %s', self._original_dir)
        os.chdir(self._original_dir)
        # TODO: delete self._working_dir or just let os clean it up ?

## ***** END Copied from osutils.py *****


DOC_KML_FILENAME = 'doc.kml'
IMAGE_NAME_MATCHER = re.compute('.*(hourly|daily_average).*\.png')

def process(input_file_pathname, output_file_pathname):
    with create_working_dir() as w_dir:
        zip_file = zipfile.ZipFile(input_file_pathname, 'r')
        new_file_pathname = os.path.join(w_dir, os.path.basename(output_file_pathname))
        new_zip_file = zipfile.ZipFile(new_file_pathname, 'w')
        for zip_info in zip_info.infolist():
            if zip_info.orig_filename == DOC_KML_FILENAME:
                    IMAGE_NAME_MATCHER.test(zip_info.orig_filename)):
                # TODO: make sure this doesn't affect originall
                zip_file.extract(zip_info.orig_filename)
                if zip_info.orig_filename == DOC_KML_FILENAME:
                    # TODO: modify xml
                    # with open() as f:
                    #     read it....
                    # with open(, 'w') as f:
                    #     f.write(xmltodict.unparse(xml))
                    pass
                new_zip_file.write(zip_info.orig_filename)

        shutil.copyfile(new_file_pathname, output_file_pathname)


def create_sym_link(output_file_pathname, sym_link_pathname):
    if os.path.exists(sym_link_pathname):
        os.remove(sym_link_pathname)
    os.symlink(output_file_pathname, sym_link_pathname)

def main():
    args  = parse_args()
    configure_logging(args)
    validate_args(args)

    input_file_pathname, timestamp = find_latest(args.input_dir,
        args.input_filename)
    if not input_file_pathname:
        logging.warn("Failed to find any input files matching %s under %s.",
            args.input_filename, args.input_dir)
        sys.exit(0) # not really an error, so exit with 0

    output_file_pathname = generate_output_file_pathname(args.output_dir,
        args.output_filename, timestamp)

    if not os.path.isfile(output_file_pathname):
        process(input_file_pathname, output_file_pathname)
        create_sym_link(output_file_pathname,
            os.path.join(output_dir, output_filename)
    else:
        logging.info("Latest file, %s, was already processed",
            output_file_pathname)

if __name__ == "__main__":
    main()
