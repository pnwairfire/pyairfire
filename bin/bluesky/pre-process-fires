#!/usr/bin/env python

"""pre-process-fires: script to combine and filter fires from one or more
BleuSky fire_locations.csv files

Note: This script is self-contained, in that it's not dependent on any modules
in pyairfire. This was done to allow sharing by means of simply passing around
the script file rather than by installing pyairfire with pip.

See usage string, below, for examples calls
"""

__author__      = "Joel Dubowy"
__copyright__   = "Copyright (c) 2015 AirFire, PNW, USFS"

import csv
import sys
from optparse import OptionValueError, OptionParser

USAGE = """%prog filename[:countrycode[,countrycode]] ...

where country codes, if specified, are used as a whitelist for filtering fires.

Example:
 > pre-process-fires fire_locations_1.csv fire_locations_2.csv:CA,USA"""

def error_and_exit(msg, parser):
    print '\n** ' + str(msg) + ' **\n'
    parser.print_help()
    sys.exit(1)

class FiresMerger(object):

    class FireFile(object):
        def __init__(self, file_specifier):
            a = file_specifier.split(':')
            if len(a) > 2:
                raise RuntimeError("Invalid fire file specifier: %s" % (file_specifier))
            self.file_name = a[0]
            if len(a) == 2:
                if not a[1]:
                    raise RuntimeError("Invalid fire file specifier: %s" % (file_specifier))
                self.country_code_whitelist = set(a[1].split(','))
            else:
                self.country_code_whitelist = None

    def __init__(self, *fire_files):
        self._fire_files = [FiresMerger.FireFile(f) for f in fire_files]
        self._merge()

    def _merge(self):
        self._headers = None
        self._fires = reduce(lambda a,b: a+b,
            [self._process_file(f) for f in self._fire_files])

    def _process_file(self, f):
        rows = []
        with open(f.file_name, 'r') as input_file:
            headers = []
            for row in csv.reader(input_file):
                if not headers:
                    headers = [e.strip(' ') for e in row]
                    if not self._headers:
                        self._headers = headers
                    else:
                        if self._headers != headers:
                            raise RuntimeError("CSV file headers don't match")
                    headers = dict([(headers[i], i) for i in xrange(len(headers))])
                else:
                    if (not f.country_code_whitelist or
                        row[headers['country']] in f.country_code_whitelist):
                        rows.append(row)
        return rows

    def write(self, output_file=None):
        stream = open(output_file, 'w') if output_file else sys.stdout
        csvfile = csv.writer(stream, lineterminator='\n')
        csvfile.writerow(self._headers)
        for f in self._fires:
            csvfile.writerow(f)

def main():
    parser = OptionParser(usage=USAGE)
    parser.add_option('-o', '--output-file', #meta=FILE,
        help='output file to contain new set of fires; by default, writes to stdout')
    options, fire_files = parser.parse_args()
    if not fire_files:
        error_and_exit("Specify one or more fire locations csv files", parser)

    try:
        fm = FiresMerger(*fire_files)
        fm.write(options.output_file)
    except Exception, e:
        error_and_exit(e, parser)

if __name__ == "__main__":
    main()
