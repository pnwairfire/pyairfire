#!/usr/bin/env python

"""read-status-log: Script to ....

Note: This script doesn't buy you much more than you can do with curl.  It's
mostly for testing the underlying statuslogging.StatusReader class

Example calls:
 > ./bin/statuslogging/read-status-log \
    -e http://status-log-production.herokuapp.com/status-logs
 > ./bin/statuslogging/read-status-log -l 10 -o 20 -q status=Good \
    -e http://status-log-production.herokuapp.com/status-logs
"""

__author__      = "Joel Dubowy"
__copyright__   = "Copyright (c) 2015 AirFire, PNW, USFS"

import re
import sys
from optparse import OptionParser

try:
    from pyairfire import statuslogging, scripting
except:
    import os
    root_dir = os.path.abspath(os.path.join(sys.path[0], '../../'))
    sys.path.insert(0, root_dir)
    from pyairfire import statuslogging, scripting

# Note: though some argue that all required parameters should be specified as
# positional arguments, I prefer using 'options' flags, even though this
# means that there are required 'options', which is oxymoronic.

REQUIRED_OPTIONS = [
    {
        'short': '-e',
        'long': '--api-endpoint',
        'dest': 'api_endpoint',
        'help': 'status logger query API endpoint (required)'
    }
]

OPTIONAL_OPTIONS = [
    {
        'short': "-q",
        'long': "--query",
        'type': "string",
        'dest': "query",
        'action': "callback",
        'help': "extra query parameters",
        'default': {},
        'callback': scripting.options.extract_and_set_key_value
    },
    {
        'short': "-l",
        'long': "--limit",
        'type': "int",
        'dest': "limit",
        'help': "maximum number of status logs to be returned by API"
    },
    {
        'short': "-o",
        'long': "--offset",
        'type': "int",
        'dest': "offset",
        'help': "offset used in conjunction with limit"
    },
    {
        'short': "-n",
        'long': "--newer-than",
        'type': "string",
        'dest': "newer_than",
        'action': "callback",
        'help': "Only return entries newer than this datetime",
        'default': None,
        'callback': scripting.options.parse_datetime
    },
    {
        'short': "-p",
        'long': "--older-than",
        'type': "string",
        'dest': "older_than",
        'action': "callback",
        'help': "Only return entries older than this datetime",
        'default': None,
        'callback': scripting.options.parse_datetime
    },
    {
        'short': "-r",
        'long': "--most-recent-by-group",
        'dest': "most_recent_by_group",
        'help': "group by this entry data field (ex. 'domain'"
    }
]

def main():
    parser, options, args = scripting.options.parse_options(
        REQUIRED_OPTIONS + OPTIONAL_OPTIONS)
    scripting.options.check_required_options(options, REQUIRED_OPTIONS, parser)
    scripting.options.configure_logging_from_options(options, parser)
    #output_options(options)
    scripting.options.output_options(options)

    try:
        sr = statuslogging.StatusReader(options.api_endpoint)
        logs = sr.read(limit=options.limit, offset=options.offset,
            newer_than=options.newer_than, older_than=options.older_than,
            most_recent_by_group=options.most_recent_by_group,
            **dict(options.query))
        print logs
    except Exception, e:
        scripting.utils.exit_with_msg(e.message)

if __name__ == "__main__":
    main()
