#!/usr/bin/env python

"""read-status-log: Script to ....

Note: Without using the email or sms options, this script doesn't
buy you much more than you can do with curl.  It's
mostly for testing the underlying statuslogging.StatusReader class

Example calls:
 > ./bin/statuslogging/read-status-log \
    -e http://status-log-production.herokuapp.com/status-logs
 > ./bin/statuslogging/read-status-log -l 10 -o 20 -q status=Good \
    -e http://status-log-production.herokuapp.com/status-logs

Check out MailCatcher (http://mailcatcher.me/) to test email notications
    gem install mailcatcher
"""

__author__      = "Joel Dubowy"
__copyright__   = "Copyright (c) 2015 AirFire, PNW, USFS"

import json
import re
import sys

try:
    from pyairfire import statuslogging, scripting
except:
    import os
    root_dir = os.path.abspath(os.path.join(sys.path[0], '../../'))
    sys.path.insert(0, root_dir)
    from pyairfire import statuslogging, scripting

# Note: though some argue that all required parameters should be specified as
# positional arguments, I prefer using 'options' flags, even though this
# means that there are required 'options', which is oxymoronic.

REQUIRED_OPTIONS = [
    {
        'short': '-e',
        'long': '--api-endpoint',
        'dest': 'api_endpoint',
        'help': 'status logger query API endpoint (required)'
    }
]

OPTIONAL_OPTIONS = [
    # Query Options
    {
        'short': "-q",
        'long': "--query",
        'type': "string",
        'dest': "query",
        'action': "callback",
        'help': "extra query parameters",
        'default': {},
        'callback': scripting.options.extract_and_set_key_value
    },
    {
        'short': "-l",
        'long': "--limit",
        'type': "int",
        'dest': "limit",
        'help': "maximum number of status logs to be returned by API"
    },
    {
        'short': "-o",
        'long': "--offset",
        'type': "int",
        'dest': "offset",
        'help': "offset used in conjunction with limit"
    },
    {
        'short': "-n",
        'long': "--newer-than",
        'type': "string",
        'dest': "newer_than",
        'action': "callback",
        'help': "Only return entries newer than this datetime",
        'default': None,
        'callback': scripting.options.parse_datetime
    },
    {
        'short': "-p",
        'long': "--older-than",
        'type': "string",
        'dest': "older_than",
        'action': "callback",
        'help': "Only return entries older than this datetime",
        'default': None,
        'callback': scripting.options.parse_datetime
    },
    {
        'short': "-r",
        'long': "--most-recent-by-group",
        'dest': "most_recent_by_group",
        'help': "group by this entry data field (ex. 'domain'"
    },
    # Email options
    {
        'short': '-t',
        'long': "--email-recipients",
        'dest': "email_recipients",
        'help': "email addresses to send queried logs to",
        'action': 'append',
        'default': []
    },
    {
        'long': "--email-sender",
        'dest': "email_sender",
        'help': "from email address for queried log email"
    },
    {
        'short': '-s',
        'long': "--email-subject",
        'dest': "email_subject",
        'help': "subject of email"
    },
    {
        'short': '-m',
        'long': "--smtp-server",
        'dest': "smtp_server",
        'help': "SMTP server host and port (ex. 'smtp.google.com:587')"
    },
    {
        'long': "--smtp-username",
        'dest': "smtp_username",
        'help': "Username to log into SMTP server"
    },
    {
        'long': "--smtp-password",
        'dest': "smtp_password",
        'help': "Password to log into SMTP server"
    },
    {
        'long': "--smtp-starttls",
        'dest': "smtp_starttls",
        'help': "Use STARTTLS",
        'action': 'store_true',
        'default': False
    },
    # # SMS options  <-- not supported
    # {
    #     'long': "--sms-recipients",
    #     'dest': "sms_recipients",
    #     'help': "phone numbers to to send queried log SMS to",
    #     'action': 'append',
    #     'default': []
    # },
    # {
    #     'long': "--sms-sender",
    #     'dest': "sms_sender",
    #     'help': "from phone number for queried log SMS"
    # },
    # General Options
    {
        'long': "--quiet",
        'dest': "quiet",
        'help': "suppress ouput of queried logs",
        'action': 'store_true',
        'default': False
    }
]

def main():
    parser, options, args = scripting.options.parse_options(REQUIRED_OPTIONS,
        OPTIONAL_OPTIONS)

    try:
        query = dict(options.query)

        # read
        sr = statuslogging.StatusReader(options.api_endpoint)
        logs = sr.read(limit=options.limit, offset=options.offset,
            newer_than=options.newer_than, older_than=options.older_than,
            most_recent_by_group=options.most_recent_by_group, **query)

        # notify
        sn = statuslogging.StatusNotifier(**options.__dict__)
        sn.send(logs, subject=options.email_subject, query=query)

        if not options.quiet:
            # dump to output
            sys.stdout.write(json.dumps(logs))

    except Exception, e:
        scripting.utils.exit_with_msg(e.message)

if __name__ == "__main__":
    main()
